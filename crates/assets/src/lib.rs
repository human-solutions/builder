//! # Builder Assets
//!
//! This crate provides a unified asset system for the builder tool that handles:
//! - Multiple file encodings (Brotli, Gzip, Identity)
//! - Multiple languages with proper content negotiation
//! - Efficient URL-based asset lookups
//! - File path construction for both regular and translated files
//!
//! ## Key Concepts
//!
//! - **Asset**: A specific variant of a file (particular encoding + language)
//! - **AssetSet**: All variants of a single logical asset (different encodings/languages)
//! - **AssetCatalog**: Efficient collection of AssetSets for URL-based lookups
//! - **FilePathParts**: Building blocks for constructing file system paths
//!
//! ## Usage Example
//!
//! ```rust
//! use builder_assets::*;
//! use icu_locid::langid;
//!
//! // This would typically be generated by AssembleCmd
//! static MOCK_PROVIDER: fn(&str) -> Option<Vec<u8>> = mock_provider;
//! fn mock_provider(path: &str) -> Option<Vec<u8>> {
//!     match path {
//!         "css/style.css" => Some(b"body { color: blue; }".to_vec()),
//!         "css/style.css.br" => Some(b"compressed css".to_vec()),
//!         _ => None,
//!     }
//! }
//!
//! static PARTS: FilePathParts = FilePathParts {
//!     folder: Some("css"),
//!     name: "style",
//!     hash: None,
//!     ext: "css",
//! };
//!
//! static ENCODINGS: [Encoding; 2] = [Encoding::Identity, Encoding::Brotli];
//! static ASSET_SET: AssetSet = AssetSet {
//!     url_path: "/css/style.css",
//!     file_path_parts: PARTS,
//!     available_encodings: &ENCODINGS,
//!     available_languages: None,
//!     mime: "text/css",
//!     provider: &MOCK_PROVIDER,
//! };
//!
//! // Content negotiation
//! let asset = ASSET_SET.asset_for("br, gzip", "en");
//! assert_eq!(asset.encoding, Encoding::Brotli);
//! assert_eq!(asset.file_path(), "css/style.css.br");
//!
//! // Load the actual data
//! let data = asset.data_for();
//! assert_eq!(data, b"compressed css");
//! ```
//!
//! ## File Path Patterns
//!
//! The system supports two file path patterns:
//!
//! - **Regular files**: `folder/name[.hash].ext[.encoding_ext]`
//!   - Example: `css/style.css`, `css/style.hash123=.css.br`
//!
//! - **Translated files**: `folder/name[.hash].ext/lang.ext[.encoding_ext]`
//!   - Example: `css/button.css/fr.css`, `css/button.hash123=.css/en.css.br`
//!
//! ## Content Negotiation
//!
//! The system performs HTTP-style content negotiation:
//! - **Language negotiation**: Uses `fluent-langneg` for proper locale matching
//! - **Encoding negotiation**: Respects client preferences with quality values
//! - **Fallbacks**: Always returns a valid asset, preferring better encodings

pub mod asset;
pub mod asset_set;
pub mod catalog;
pub mod encoding;
pub mod file_path;
pub mod negotiation;
pub mod runtime_config;

// Re-export the main public API
pub use asset::Asset;
pub use asset_set::AssetSet;
pub use catalog::AssetCatalog;
pub use encoding::Encoding;
pub use file_path::FilePathParts;
pub use runtime_config::{get_asset_base_path, get_asset_base_path_or_panic, set_asset_base_path};

// Re-export icu_locid for convenience since it's part of the public API
pub use icu_locid::{LanguageIdentifier, langid};

// Re-export rust_embed for generated code
pub use rust_embed::Embed;

// Re-export std::path for filesystem operations
pub use std::path::PathBuf;

#[cfg(test)]
mod integration_tests {
    use super::*;
    use icu_locid::langid;

    // Mock provider that simulates filesystem/embedded access
    static TEST_PROVIDER: fn(&str) -> Option<Vec<u8>> = test_provider;
    fn test_provider(path: &str) -> Option<Vec<u8>> {
        match path {
            // Regular files
            "assets/style.css" => Some(b"body { color: blue; }".to_vec()),
            "assets/style.css.gzip" => Some(b"gzipped css".to_vec()),
            "assets/style.css.br" => Some(b"brotli css".to_vec()),

            // Translated files
            "assets/button.hash123=.css/en.css" => Some(b"button { background: blue; }".to_vec()),
            "assets/button.hash123=.css/fr.css" => Some(b"bouton { arriere-plan: bleu; }".to_vec()),
            "assets/button.hash123=.css/en.css.br" => Some(b"compressed english button".to_vec()),
            "assets/button.hash123=.css/fr.css.br" => Some(b"compressed french button".to_vec()),

            // Font file
            "fonts/roboto.woff2" => Some(b"font data".to_vec()),

            _ => None,
        }
    }

    static STYLE_PARTS: FilePathParts = FilePathParts {
        folder: Some("assets"),
        name: "style",
        hash: None,
        ext: "css",
    };
    static STYLE_ENCODINGS: [Encoding; 3] = [Encoding::Identity, Encoding::Gzip, Encoding::Brotli];
    static BUTTON_PARTS: FilePathParts = FilePathParts {
        folder: Some("assets"),
        name: "button",
        hash: Some("hash123="),
        ext: "css",
    };
    static BUTTON_ENCODINGS: [Encoding; 2] = [Encoding::Identity, Encoding::Brotli];
    static BUTTON_LANGUAGES: [LanguageIdentifier; 2] = [langid!("en"), langid!("fr")];

    static STYLE_ASSET: AssetSet = AssetSet {
        url_path: "/assets/style.css",
        file_path_parts: STYLE_PARTS,
        available_encodings: &STYLE_ENCODINGS,
        available_languages: None,
        mime: "text/css",
        provider: &TEST_PROVIDER,
    };

    static BUTTON_ASSET: AssetSet = AssetSet {
        url_path: "/assets/button.hash123=.css",
        file_path_parts: BUTTON_PARTS,
        available_encodings: &BUTTON_ENCODINGS,
        available_languages: Some(&BUTTON_LANGUAGES),
        mime: "text/css",
        provider: &TEST_PROVIDER,
    };

    #[test]
    fn test_complete_workflow() {
        // Create catalog
        let mut catalog = AssetCatalog::new();
        catalog.add_asset(&STYLE_ASSET);
        catalog.add_asset(&BUTTON_ASSET);

        // Test basic asset lookup and content negotiation
        let asset = catalog.get_asset("/assets/style.css", "br, gzip", "");
        assert!(asset.is_some());
        let asset = asset.unwrap();
        assert_eq!(asset.encoding, Encoding::Brotli);
        assert_eq!(asset.file_path(), "assets/style.css.br");
        assert_eq!(asset.data_for(), b"brotli css");

        // Test translated asset with content negotiation
        let asset = catalog.get_asset("/assets/button.hash123=.css", "br", "fr-CA, fr, en");
        assert!(asset.is_some());
        let asset = asset.unwrap();
        assert_eq!(asset.encoding, Encoding::Brotli);
        assert_eq!(asset.lang, Some(langid!("fr")));
        assert_eq!(asset.file_path(), "assets/button.hash123=.css/fr.css.br");
        assert_eq!(asset.data_for(), b"compressed french button");

        // Test fallback when preferred isn't available
        let asset = catalog.get_asset("/assets/button.hash123=.css", "gzip", "de, en");
        assert!(asset.is_some());
        let asset = asset.unwrap();
        assert_eq!(asset.encoding, Encoding::Brotli); // Most preferred available encoding
        assert_eq!(asset.lang, Some(langid!("en"))); // Fallback language
    }

    static FONT_PARTS: FilePathParts = FilePathParts {
        folder: Some("fonts"),
        name: "roboto",
        hash: None,
        ext: "woff2",
    };
    static FONT_ENCODINGS: [Encoding; 1] = [Encoding::Identity];

    static FONT_ASSET: AssetSet = AssetSet {
        url_path: "/fonts/roboto.woff2",
        file_path_parts: FONT_PARTS,
        available_encodings: &FONT_ENCODINGS,
        available_languages: None,
        mime: "font/woff2",
        provider: &TEST_PROVIDER,
    };

    #[test]
    fn test_catalog_operations() {
        let mut catalog = AssetCatalog::new();
        catalog.add_asset(&FONT_ASSET);

        // Test catalog queries
        assert_eq!(catalog.len(), 1);
        assert!(catalog.contains_url("/fonts/roboto.woff2"));
        assert!(!catalog.contains_url("/fonts/missing.woff2"));

        // Test MIME type operations
        let mime_types = catalog.mime_types();
        assert_eq!(mime_types, vec!["font/woff2"]);

        let font_assets: Vec<_> = catalog.assets_by_mime_type("font/woff2").collect();
        assert_eq!(font_assets.len(), 1);
        assert_eq!(font_assets[0].url(), "/fonts/roboto.woff2");
    }

    #[test]
    fn test_file_path_construction_edge_cases() {
        // Test various FilePathParts configurations
        let parts = FilePathParts {
            folder: None,
            name: "favicon",
            hash: Some("xyz="),
            ext: "ico",
        };

        // No folder, with hash
        assert_eq!(
            parts.construct_path(Encoding::Identity, None),
            "favicon.xyz=.ico"
        );

        // With language
        let lang = langid!("en-US");
        assert_eq!(
            parts.construct_path(Encoding::Brotli, Some(&lang)),
            "favicon.xyz=.ico/en-US.ico.br"
        );

        // URL path (no encoding)
        assert_eq!(parts.construct_url_path(), "/favicon.xyz=.ico");
    }

    static TEST_FILE_PARTS: FilePathParts = FilePathParts {
        folder: Some("test"),
        name: "file",
        hash: None,
        ext: "txt",
    };
    static TEST_FILE_ENCODINGS: [Encoding; 3] =
        [Encoding::Identity, Encoding::Gzip, Encoding::Brotli];

    static TEST_FILE_ASSET: AssetSet = AssetSet {
        url_path: "/test/file.txt",
        file_path_parts: TEST_FILE_PARTS,
        available_encodings: &TEST_FILE_ENCODINGS,
        available_languages: None,
        mime: "text/plain",
        provider: &TEST_PROVIDER,
    };

    #[test]
    fn test_encoding_preference() {
        // Brotli should be preferred
        let asset = TEST_FILE_ASSET.asset_for("br, gzip", "");
        assert_eq!(asset.encoding, Encoding::Brotli);

        // Quality values should be respected (gzip q=1.0 beats br q=0.8)
        let asset = TEST_FILE_ASSET.asset_for("gzip; q=1.0, br; q=0.8", "");
        assert_eq!(asset.encoding, Encoding::Gzip);

        // Fallback to most preferred available when none match
        let asset = TEST_FILE_ASSET.asset_for("compress", ""); // Unknown encoding
        assert_eq!(asset.encoding, Encoding::Brotli); // Most preferred available
    }
}

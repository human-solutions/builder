use anyhow::Result;
use camino_fs::{Utf8Path, Utf8PathExt};
use std::collections::BTreeMap;

/// Converts a file path to a valid Rust constant name
/// Removes hash part, converts to uppercase, and replaces invalid characters with underscores
fn file_path_to_const_name(file_path: &str) -> String {
    let mut const_name = String::new();

    // Split the path and remove any hash parts (parts ending with '=')
    for part in file_path.split('/') {
        if !const_name.is_empty() {
            const_name.push('_');
        }

        // Split by '.' to separate name, potential hash, and extension
        let parts: Vec<&str> = part.split('.').collect();

        if parts.len() >= 2 {
            // Add the name part
            const_name.push_str(&sanitize_for_const(parts[0]));

            // Find the extension (last part that's not a hash)
            let mut ext_parts = Vec::new();
            for p in parts.iter().skip(1) {
                if !p.ends_with('=') {
                    ext_parts.push(*p);
                }
            }

            // Add extension parts
            for ext in ext_parts {
                const_name.push('_');
                const_name.push_str(&sanitize_for_const(ext));
            }
        } else {
            const_name.push_str(&sanitize_for_const(part));
        }
    }

    const_name.to_uppercase()
}

/// Sanitizes a string part for use in a Rust constant name
fn sanitize_for_const(s: &str) -> String {
    s.chars()
        .map(|c| if c.is_ascii_alphanumeric() { c } else { '_' })
        .collect()
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct HashEntry {
    pub file_path: String,
    pub hash: String,
}

impl HashEntry {
    pub fn new<P: Into<String>, H: Into<String>>(file_path: P, hash: H) -> Self {
        Self {
            file_path: file_path.into(),
            hash: hash.into(),
        }
    }
}

/// Collects hash entries and writes them to a Rust file
pub struct HashCollector {
    entries: BTreeMap<String, String>,
}

impl HashCollector {
    pub fn new() -> Self {
        Self {
            entries: BTreeMap::new(),
        }
    }

    pub fn add_entry<P: Into<String>, H: Into<String>>(&mut self, file_path: P, hash: H) {
        self.entries.insert(file_path.into(), hash.into());
    }

    pub fn write_to_rust_file(&self, output_path: &Utf8Path) -> Result<()> {
        let rust_content = self.generate_rust_code();

        // Ensure parent directory exists
        if let Some(parent) = output_path.parent() {
            parent.mkdirs()?;
        }

        output_path.write(&rust_content)?;
        Ok(())
    }

    fn generate_rust_code(&self) -> String {
        let mut content = String::new();

        content.push_str("// This file is auto-generated by the builder tool.\n");
        content.push_str("// Do not edit manually - it will be overwritten.\n\n");

        if self.entries.is_empty() {
            content.push_str("// No files with hashes were generated.\n");
        } else {
            for (file_path, hash) in &self.entries {
                let const_name = file_path_to_const_name(file_path);
                content.push_str(&format!("pub const {}: &str = \"{}\";\n", const_name, hash));
            }
        }

        content
    }
}

impl Default for HashCollector {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_file_path_to_const_name() {
        // Basic file names
        assert_eq!(file_path_to_const_name("style.css"), "STYLE_CSS");
        assert_eq!(file_path_to_const_name("script.js"), "SCRIPT_JS");

        // Files with paths
        assert_eq!(
            file_path_to_const_name("assets/style.css"),
            "ASSETS_STYLE_CSS"
        );
        assert_eq!(
            file_path_to_const_name("js/modules/app.js"),
            "JS_MODULES_APP_JS"
        );

        // Files with hashes (should be removed)
        assert_eq!(file_path_to_const_name("style.abc123=.css"), "STYLE_CSS");
        assert_eq!(
            file_path_to_const_name("assets/script.def456=.js"),
            "ASSETS_SCRIPT_JS"
        );

        // Special characters (should be sanitized)
        assert_eq!(file_path_to_const_name("my-file.css"), "MY_FILE_CSS");
        assert_eq!(file_path_to_const_name("file@2x.png"), "FILE_2X_PNG");
    }

    #[test]
    fn test_sanitize_for_const() {
        assert_eq!(sanitize_for_const("hello"), "hello");
        assert_eq!(sanitize_for_const("hello-world"), "hello_world");
        assert_eq!(sanitize_for_const("file@2x"), "file_2x");
        assert_eq!(sanitize_for_const("123abc"), "123abc");
    }

    #[test]
    fn test_hash_collector_empty() {
        let collector = HashCollector::new();
        let rust_code = collector.generate_rust_code();
        assert!(rust_code.contains("// No files with hashes were generated."));
    }

    #[test]
    fn test_hash_collector_with_entries() {
        let mut collector = HashCollector::new();
        collector.add_entry("style.css", "abc123");
        collector.add_entry("script.js", "def456");

        let rust_code = collector.generate_rust_code();
        assert!(rust_code.contains("pub const STYLE_CSS: &str = \"abc123\";"));
        assert!(rust_code.contains("pub const SCRIPT_JS: &str = \"def456\";"));
        assert!(!rust_code.contains("FILE_HASHES")); // Should not contain the old array format
    }

    #[test]
    fn test_hash_collector_with_complex_paths() {
        let mut collector = HashCollector::new();
        collector.add_entry("assets/styles/main.css", "hash1");
        collector.add_entry("js/app.min.js", "hash2");
        collector.add_entry("images/logo@2x.png", "hash3");

        let rust_code = collector.generate_rust_code();
        assert!(rust_code.contains("pub const ASSETS_STYLES_MAIN_CSS: &str = \"hash1\";"));
        assert!(rust_code.contains("pub const JS_APP_MIN_JS: &str = \"hash2\";"));
        assert!(rust_code.contains("pub const IMAGES_LOGO_2X_PNG: &str = \"hash3\";"));
    }

    #[test]
    fn test_hash_entry_creation() {
        let entry = HashEntry::new("test.txt", "hash123");
        assert_eq!(entry.file_path, "test.txt");
        assert_eq!(entry.hash, "hash123");
    }
}
